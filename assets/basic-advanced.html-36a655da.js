import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as c,c as l,a as n,d as a,e,b as r,f as p}from"./app-508d0963.js";const i={},d={href:"https://labuladong.github.io/algo/",target:"_blank",rel:"noopener noreferrer"},u=n("code",null,"labuladong的算法小抄",-1),h={href:"https://programmercarl.com/",target:"_blank",rel:"noopener noreferrer"},k=n("code",null,"代码随想录",-1),m=n("blockquote",null,[n("p",null,[a("上述两位大佬的算法讲解已经十分完善，故本笔记只记录一些"),n("strong",null,"重难点"),a("或笔者认为"),n("strong",null,"精妙"),a("的部分，如需系统学习，请移步上述网址。"),n("br"),a(" 这篇笔记主要记录二叉树、动态规划、回溯和BFS、DFS等基础进阶内容。")])],-1),b=p(`<h2 id="一刷-labuladong的算法小抄" tabindex="-1"><a class="header-anchor" href="#一刷-labuladong的算法小抄" aria-hidden="true">#</a> 一刷-labuladong的算法小抄</h2><div class="hint-container info"><p class="hint-container-title">写在前面</p></div><h3 id="chap0-二叉树纲领" tabindex="-1"><a class="header-anchor" href="#chap0-二叉树纲领" aria-hidden="true">#</a> CHAP0- 二叉树纲领</h3><p>提取二叉树共性，对二叉树中蕴含的思维进行升华，可以应用到动态规划，回溯算法，分治算法，图论算法等等中去。</p><p>例如：</p><blockquote><p>快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历。<br> 快速排序：先构造分界点，然后去左右子数组构造分界点。<br> 归并排序：先对左右子数组排序，然后合并。</p></blockquote><p>二叉树遍历框架：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 前序位置</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 中序位置</span>
    <span class="token function">traverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 后序位置</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不管前中后序遍历是什么顺序，只需将具体操作嵌上述遍历框架中，再改变顺序，就是二叉树遍历的大部分情况。</p><blockquote><p><strong>只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。</strong></p></blockquote><p>二叉树题目的递归解法可以分两类思路，第一类是<strong>遍历</strong>一遍二叉树得出答案，第二类是通过<strong>分解</strong>问题计算出答案，这两类思路分别对应着<strong>回溯算法</strong>核心框架和<strong>动态规划</strong>核心框架。</p><h3 id="chap1-前中后序遍历" tabindex="-1"><a class="header-anchor" href="#chap1-前中后序遍历" aria-hidden="true">#</a> CHAP1- 前中后序遍历</h3>`,12),v={href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},_=n("p",null,[a("解法1: 分解为求左右子树的最大深度，再加上自己。"),n("br"),a(" 解法2: 遍历二叉树，注意深度更新位置与res更新时机。")],-1);function g(f,x){const s=o("ExternalLinkIcon");return c(),l("div",null,[n("p",null,[a("这是一篇算法刷题笔记，主要轨迹按照"),n("a",d,[u,e(s)]),a("和"),n("a",h,[k,e(s)]),a("进行学习。")]),m,r(" more "),b,n("ol",null,[n("li",null,[n("p",null,[a("题目("),n("a",v,[a("leetcode"),e(s)]),a(")")]),_])])])}const y=t(i,[["render",g],["__file","basic-advanced.html.vue"]]);export{y as default};
