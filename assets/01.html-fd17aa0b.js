import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as i,c as _,b as c,a as t,d as o,e,w as n,f as d}from"./app-508d0963.js";const a={},u=t("p",null,"Redis面试题汇总（基础篇）",-1),h=d('<h3 id="_1-redis基础数据结构" tabindex="-1"><a class="header-anchor" href="#_1-redis基础数据结构" aria-hidden="true">#</a> 1. Redis基础数据结构</h3><p><strong>问：Redis有哪些基础数据结构？</strong><br> 答：Redis共有5种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p><p><strong>问：说明一下每个数据结构，并且给我列举几个每种数据结构的应用场景？</strong><br> 答：常用场景可见下表：</p><table><thead><tr><th><strong>数据结构</strong></th><th>String</th><th>List</th><th>Set</th><th>Hash</th><th>Zset</th></tr></thead><tbody><tr><td><strong>描述</strong></td><td>字符串</td><td>列表</td><td>集合</td><td>散列</td><td>有序集合</td></tr><tr><td><strong>说明</strong></td><td>一种二进制安全的数据类型，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td><td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td><td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。</td><td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td><td>和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</td></tr><tr><td><strong>常用场景</strong></td><td>缓存、Token、地址、序列化后的对象</td><td>最新文章、动态</td><td>不能重复的数据（如点赞统计）、需要计算数据交集或并集的场景</td><td>用户信息、商品信息、文章信息等</td><td>排行榜</td></tr></tbody></table><h3 id="_2-redis持久化" tabindex="-1"><a class="header-anchor" href="#_2-redis持久化" aria-hidden="true">#</a> 2. Redis持久化</h3>',5),F=t("strong",null,"问：Redis持久化有哪些方式？",-1),g=t("br",null,null,-1),A=t("strong",null,"RDB",-1),O=t("strong",null,"AOF",-1),p=t("strong",null,"问：光这样说我听不懂啊，RDB和AOF分别是什么意思？",-1),R=t("br",null,null,-1),b=t("strong",null,"创建快照",-1),f=t("strong",null,"某个时间点",-1),m=t("p",null,[t("strong",null,"问：RDB创建快照时会阻塞主线程吗？"),t("br"),o(" 答：Redis默认采用"),t("code",null,"bgsave"),o("，会fork出一个子进程，不会影响主进程（主线程），如果使用"),t("code",null,"save"),o("命令，则会阻塞主进程。")],-1),S=t("p",null,[t("strong",null,"问：明白了，再介绍一下AOF持久化吧？"),t("br"),o(" 答：AOF是指将"),t("strong",null,"写操作"),o("保存到日志种的持久化方式（不用保存读操作，因为对数据没有影响），如果Redis服务器宕机重启了，读取AOF日志即可重新获得保存AOF文件时的Redis数据。")],-1),E=t("strong",null,"问：AOF文件的写入时机了解吗？",-1),v=t("br",null,null,-1),B=t("br",null,null,-1),y=t("strong",null,"避免额外的检查开销",-1),x=t("strong",null,"不会阻塞当前写操作命令执行",-1),N=t("strong",null,"问：那这个策略会带来什么问题吗？",-1),D=t("br",null,null,-1),k=t("strong",null,"数据可能会丢失",-1),V=t("strong",null,"可能阻塞下一条命令",-1),w=d("<p><strong>问：我注意到你说RDB会fork一个子进程，而AOF会阻塞主进程？</strong><br> 答：实际上，AOF一般也不会造成阻塞，虽然AOF持久化是顺序执行的，但是Redis使用了操作系统的异步写入机制，但在数据过于庞大的情况下，仍有可能阻塞主进程。</p><p><strong>问：很好，我还对这个AOF感兴趣，再讲讲？</strong><br> 答：造成上述AOF问题的原因，其实都跟<strong>AOF日志写回时机</strong>有关。Redis写入AOF时，提供了3种写回策略：</p><ul><li><code>Always</code>，每次写操作执行完后，都同步将AOF日志写回到硬盘；</li><li><code>Everysec</code>，每次写操作执行完后，先讲命令写入AOF文件的内核缓冲区，然后每秒执行一次AOF文件写回；</li><li><code>No</code>，不由Redis控制写回时机，由操作系统控制写回。<br> 每种策略的优略也很明显了，<code>Always</code>可靠性最高，但性能开销最大，而<code>No</code>的可靠性最低，但是性能最好；<code>Everysec</code>相对折中。</li></ul>",3),H=t("strong",null,"问：这个AOF文件不会越来越大吗？",-1),L=t("br",null,null,-1),C=t("br",null,null,-1),T=t("strong",null,"AOF重写机制",-1),J=t("br",null,null,-1),M=t("p",null,[t("strong",null,"问：明白了，那这个AOF重写是不是也跟AOF写入一样，是在主进程完成呢？"),t("br"),o(" 答：好问题，AOF日志的写入是在主进程执行的，因为他每次写入内容不多，一般不会太影响，但是AOF重写时，需要读写大量操作，所以是在后台"),t("strong",null,"子进程"),o("（注意是子进程，不是子线程）执行的。"),t("br"),o(" 答：这样带来两个好处：不影响主进程执行、子进程会自动创建数据副本。")],-1),Z=t("p",null,[t("strong",null,"问：你刚刚让我注意AOF重写时子进程和子线程的区别，什么意思？"),t("br"),o(" 答：下回分解")],-1);function Q(j,q){const s=r("font");return i(),_("div",null,[u,c(" more "),h,t("p",null,[F,g,o(" 答：Redis支持3种持久化方式，分别是快照（"),e(s,{color:"#304FFE"},{default:n(()=>[A]),_:1}),o(", snapshotting）、只追加文件（"),e(s,{color:"#304FFE"},{default:n(()=>[O]),_:1}),o(", apend-only file）、RDB与AOF混合（Redis4.0后新增）。")]),t("p",null,[p,R,o(" 答：先介绍RDB持久化吧，Redis 可以通过"),e(s,{color:"#304FFE"},{default:n(()=>[b]),_:1}),o("来获得存储在内存里面的数据在"),f,o("上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，还可以将快照留在原地以便重启服务器的时候使用，快照持久化是 Redis 默认采用的持久化方式。")]),m,S,t("p",null,[E,v,o(" 答：Redis保存AOF文件时和MySQL策略不同，Redis是先执行写操作命令，然后才将该记录写入AOF日志。"),B,o(" 答：这样做会带来两个好处：其一，"),e(s,{color:"#304FFE"},{default:n(()=>[y]),_:1}),o("（写操作成功执行则说明这个操作是没有语法等问题的，如果先写入AOF的话需要额外进行检查）；其二，"),e(s,{color:"#304FFE"},{default:n(()=>[x]),_:1}),o("（因为已经写入完成后才进行AOF写入）。")]),t("p",null,[N,D,o(" 答：当然有，上述两个好处也会带来两个相应风险：其一，"),e(s,{color:"#304FFE"},{default:n(()=>[k]),_:1}),o("（如果某个写操作完成后，AOF还没来得及写入就宕机了，那么这个写操作的数据就丢失了）；其二，"),e(s,{color:"#304FFE"},{default:n(()=>[V]),_:1}),o("（因为写入AOF的操作是在主进程同步完成的）。")]),w,t("p",null,[H,L,o(" 答：聪明如你，AOF日志其实就是个文本文件，随着写操作命令增多，AOF文件也会变大。如果AOF文件过大，Redis服务重启后就会花费大量时间来读取AOF文件，造成时间损耗。"),C,o(" 答：Redis为了避免AOF文件过大，提供了"),e(s,{color:"#304FFE"},{default:n(()=>[T]),_:1}),o("，定期重写AOF来实现文件压缩。"),J,o(" 答：重写的机制在于，如果某个键的值被多次修改，重写时只会记录最后一次修改的值（之前的修改直接舍弃），从而实现文件压缩。")]),M,Z])}const I=l(a,[["render",Q],["__file","01.html.vue"]]);export{I as default};
