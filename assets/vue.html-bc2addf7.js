import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as i,c,a as n,d as s,e,b as l,f as t}from"./app-2a58fa80.js";const r="/assets/components-7fbb3771.png",u={},d={href:"https://vuejs.org/",target:"_blank",rel:"noopener noreferrer"},k=n("code",null,"vue.js",-1),v=n("br",null,null,-1),m={href:"https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref",target:"_blank",rel:"noopener noreferrer"},h=n("blockquote",null,[n("p",null,"这篇文章将全部使用Vue3，并按照Vue官方推荐的组合式API和setup语法糖🍬进行coding")],-1),g=n("h2",{id:"_1-vue-js简介",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1-vue-js简介","aria-hidden":"true"},"#"),s(" 1. vue.js简介")],-1),b=n("p",null,"Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。由于Vue2将于2023年末停止维护，本文章只介绍Vue3。",-1),f={class:"hint-container info"},_=n("p",{class:"hint-container-title"},"Vue与React",-1),y={href:"https://react.dev/",target:"_blank",rel:"noopener noreferrer"},w=n("li",null,"美团、去哪儿等产品矩阵使用了Vue进行开发。",-1),x=n("p",null,[s("使用Vue3等框架之前，需要对HTML, CSS, JavaScript和Node.js有一定基础。在项目的实际开发中，还建议使用Typescript，实现更好的代码规范和代码提示。"),n("br"),s(" 开发和部署时，还可能会用到WebPack和Vite等打包构建工具。")],-1),V={href:"https://cn.vuejs.org/guide/typescript/composition-api.html",target:"_blank",rel:"noopener noreferrer"},C=n("h2",{id:"_2-响应式入门",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2-响应式入门","aria-hidden":"true"},"#"),s(" 2. 响应式入门")],-1),P={href:"https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref",target:"_blank",rel:"noopener noreferrer"},j=t(`<blockquote><p>响应式(Reactive)是一个编程概念,它允许我们以声明式的方式来更新应用的状态和视图。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">响应式编程的基本思想</p><ul><li>应用状态存储在响应式变量中。</li><li>通过修改这些变量触发视图的自动更新。</li><li>响应式编程不需要开发者手动操作DOM,开发者只需要关注状态变化,视图会自发更新。</li></ul></div><p>在Vue.js中,响应式具体工作原理是:</p><ol><li>使用<code>defineProperty</code>或<code>Proxy</code>将数据对象转换成响应式的。</li><li>视图通过数据绑定连接到这些响应式变量上。</li><li>当变量变化时,触发<code>setter</code>更新视图。</li></ol><h3 id="声明响应式状态" tabindex="-1"><a class="header-anchor" href="#声明响应式状态" aria-hidden="true">#</a> 声明响应式状态</h3><p>Vue提供了两种声明响应式状态的方法：<code>ref</code>和<code>reactive</code>。简单来说，<code>ref</code>一般来创建基本类型数据的响应，而<code>reactive</code>用来创建对象（复杂数据类型）的响应。</p><blockquote><p>ref和ractive都可以实现深层对象的响应。</p></blockquote><p>ref内部使用了Object.defineProperty的getter/setter，而reactive是通过Proxy实现响应式的。<br> 当尝试使用ref定义复杂对象类型时，ref内部也会利用响应式Proxy代理。</p><h3 id="使用ref" tabindex="-1"><a class="header-anchor" href="#使用ref" aria-hidden="true">#</a> 使用<code>ref()</code></h3><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><h4 id="ref的工作原理" tabindex="-1"><a class="header-anchor" href="#ref的工作原理" aria-hidden="true">#</a> ref的工作原理</h4></li></ul><p>模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。<br> 在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。<br> ref的实现可以以如下代码类比：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 伪代码，不是真正的实现</span>
<span class="token keyword">const</span> myRef <span class="token operator">=</span> <span class="token punctuation">{</span>
  _value<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_value
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span> <span class="token function">value</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_value <span class="token operator">=</span> newValue
    <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 在更改值的时候trigger</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ref进阶tips" tabindex="-1"><a class="header-anchor" href="#ref进阶tips" aria-hidden="true">#</a> ref进阶Tips</h3><div class="hint-container tip"><p class="hint-container-title">ref进阶Tips</p></div>`,15),A={href:"https://cn.vuejs.org/api/reactivity-advanced.html#shallowref",target:"_blank",rel:"noopener noreferrer"},M=n("code",null,"next Tick",-1),q={href:"https://cn.vuejs.org/api/general.html#nexttick",target:"_blank",rel:"noopener noreferrer"},S=t(`<div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> nextTick <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span>
  <span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 现在 DOM 已经更新了</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),T=n("li",null,[n("p",null,"动态生成ref与ref数组："),n("p",null,"working on it...")],-1),B=n("li",null,[n("p",null,"working on it...")],-1),D=t(`<h3 id="使用reactive" tabindex="-1"><a class="header-anchor" href="#使用reactive" aria-hidden="true">#</a> 使用reactive()</h3><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>reactive()</code> 将深层地转换对象：当访问嵌套对象时，它们也会被 <code>reactive()</code> 包装。当 ref 的值是一个对象时，<code>ref()</code> 也会在内部调用它。与浅层 ref 类似，也有一个 <code>shallowReactive()</code> API 可以选择退出深层响应性。<br> 由于<code>reactive()</code>存在某些局限性，<u><strong>Vue官方建议使用 <code>ref()</code> 作为声明响应式状态的主要 API</strong></u>：</p><div class="hint-container warning"><p class="hint-container-title">reactive() 的局限性</p><ol><li>有限的值类型。</li><li>不能替换整个对象（响应性链接丢失）</li><li>对解构操作不友好。</li></ol></div><h3 id="补充" tabindex="-1"><a class="header-anchor" href="#补充" aria-hidden="true">#</a> 补充</h3>`,5),E={href:"https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#ref-unwrapping-as-reactive-object-property",target:"_blank",rel:"noopener noreferrer"},I=n("li",null,"working on it...",-1),O=n("h2",{id:"_3-vue特性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_3-vue特性","aria-hidden":"true"},"#"),s(" 3. Vue特性")],-1),J=n("a",{href:"#2-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%85%A5%E9%97%A8"},"响应式入门",-1),N=n("code",null,"ref()",-1),R={href:"https://cn.vuejs.org/guide/introduction.html",target:"_blank",rel:"noopener noreferrer"},z=t('<h2 id="_4-组件与组件间通信" tabindex="-1"><a class="header-anchor" href="#_4-组件与组件间通信" aria-hidden="true">#</a> 4. 组件与组件间通信</h2><p>组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构：</p><figure><img src="'+r+`" alt="组件" tabindex="0" loading="lazy"><figcaption>组件</figcaption></figure><p>本笔记使用构建步骤，并将Vue组件定义在单文件组件（SFC）中。</p><h3 id="组件注册" tabindex="-1"><a class="header-anchor" href="#组件注册" aria-hidden="true">#</a> 组件注册</h3><ul><li><p>全局注册</p><p>在使用单文件组件的情况下，可以通过如下方式注册组件：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> MyComponent <span class="token keyword">from</span> <span class="token string">&#39;./App.vue&#39;</span>
app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;MyComponent&#39;</span><span class="token punctuation">,</span> MyComponent<span class="token punctuation">)</span>

<span class="token comment">// 也可以通过如下方式链式调用</span>
app
  <span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;ComponentA&#39;</span><span class="token punctuation">,</span> ComponentA<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;ComponentB&#39;</span><span class="token punctuation">,</span> ComponentB<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;ComponentC&#39;</span><span class="token punctuation">,</span> ComponentC<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>全局注册虽然方便，但存在以下几点问题：</p><ol><li>全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“<strong>tree-shaking</strong>”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</li><li>全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li></ol></li><li><p>局部注册</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">import</span> ComponentA <span class="token keyword">from</span> <span class="token string">&#39;./ComponentA.vue&#39;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>ComponentA <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>局部注册的组件在后代组件（子组件的子组件等）中并不可用</p></blockquote></li></ul><h3 id="props" tabindex="-1"><a class="header-anchor" href="#props" aria-hidden="true">#</a> Props</h3><blockquote><p>通过Props，父组件可以将本组件内的变量传递给自组件。</p></blockquote><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  title<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token comment">// ?表示title是可选的</span>
  likes<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>组件内定义Props时变量应使用camelCase形式，在父组件中向子组件传递Props时使用kebab-case形式，Vue会自动进行转包。</p></blockquote><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token comment">// 子组件中Props定义</span>
<span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span> greetingMessage<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 父组件中传递</span>
<span class="token operator">&lt;</span>MyComponent greeting<span class="token operator">-</span>message<span class="token operator">=</span><span class="token string">&quot;hello&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>所有props遵循<strong>单向绑定</strong>原则。props会因父组件中数据更新而变化，但子组件不能更改props的值，props是<u><strong>只读</strong></u>的。</li></ul><p>要更改props的值，一般有如下两种情况：</p><ol><li><p>prop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性，使用<code>ref()</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;initialCounter&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 计数器只是将 props.initialCounter 作为初始值</span>
<span class="token comment">// 像下面这样做就使 prop 和后续更新无关了</span>
<span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>initialCounter<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>需要对传入的 prop 值做进一步的转换，使用<code>computed()</code>。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;size&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// 该 prop 变更时计算属性也会自动更新</span>
<span class="token keyword">const</span> normalizedSize <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span>size<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><div class="hint-container warning"><p class="hint-container-title">props是对象或数组时</p><p>因为 JavaScript 的对象和数组是按引用传递的，所以在子组件中可以直接修改对象内部的值。<br> 在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变。</p></div><ul><li>Props校验</li></ul>`,16);function L(F,H){const a=p("ExternalLinkIcon");return i(),c("div",null,[n("p",null,[s("这是一篇关于"),n("a",d,[k,e(a)]),s("的学习笔记。"),v,s(" 本笔记不是完整的Vue.js学习教程，如需系统性学习，请移步"),n("a",m,[s("官网文档"),e(a)]),s("或其它教程。")]),h,l(" more "),g,b,n("div",f,[_,n("ul",null,[n("li",null,[s("虽然主流的中国互联网大厂（BAT等）更多使用"),n("a",y,[s("React"),e(a)]),s("，但Vue等学习曲线更低，更适合中小规模的前端开发，也更适合中国开发者学习和使用。")]),w])]),x,n("p",null,[s("考虑规范开发和代码提示，采用typescript开发中大型项目会减少代码错误率并提高效率，关于Vue3中使用组合式API和Typescript进行开发，参照"),n("a",V,[s("官方文档"),e(a)]),s("进行，后文将默认采用。")]),C,n("p",null,[s("关于Vue.js的响应式与双向数据绑定等功能，官网文档已经有详细的解释，我们进行简单的回顾（详情请移步"),n("a",P,[s("官网文档"),e(a)]),s("）。")]),j,n("ol",null,[n("li",null,[n("p",null,[s("使用"),n("a",A,[s("shallowRef"),e(a)]),s("来放弃深层响应性")])]),n("li",null,[n("p",null,[s("DOM更新时机：修改了响应式状态时，DOM会自动被更新，但DOM的更新是异步的。Vue会在"),M,s("周期更新状态，以确保不管进行了多少次状态修改，每个组件都只会被更新一次。如果要等待DOM更新完成才执行额外代码，可以使用"),n("a",q,[s("nextTick()"),e(a)]),s("全局API：")]),S]),T,B]),D,n("ol",null,[n("li",null,[s("额外的ref解包细节（详情见"),n("a",E,[s("官网文档"),e(a)]),s("）")]),I]),O,n("p",null,[s("Vue提供了很多方便开发者使用的特性，极大简化了前端开发流程（例如"),J,s("中提到的"),N,s("）。除此之外，Vue还提供了计算属性、类与样式绑定和条件渲染、列表渲染、表单输入绑定等特性。这些特性上手容易，官方文档简明易懂，如需学习请直接移步至"),n("a",R,[s("官方文档"),e(a)]),s("。")]),z])}const G=o(u,[["render",L],["__file","vue.html.vue"]]);export{G as default};
